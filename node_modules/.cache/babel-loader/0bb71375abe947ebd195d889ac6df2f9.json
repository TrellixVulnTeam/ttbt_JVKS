{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.types = exports.setConcurrency = exports.imageSize = void 0;\n\nconst fs = require(\"fs\");\n\nconst path = require(\"path\");\n\nconst queue_1 = require(\"queue\");\n\nconst types_1 = require(\"./types\");\n\nconst detector_1 = require(\"./detector\"); // Maximum buffer size, with a default of 512 kilobytes.\n// TO-DO: make this adaptive based on the initial signature of the image\n\n\nconst MaxBufferSize = 512 * 1024; // This queue is for async `fs` operations, to avoid reaching file-descriptor limits\n\nconst queue = new queue_1.default({\n  concurrency: 100,\n  autostart: true\n});\n/**\n * Return size information based on a buffer\n *\n * @param {Buffer} buffer\n * @param {String} filepath\n * @returns {Object}\n */\n\nfunction lookup(buffer, filepath) {\n  // detect the file type.. don't rely on the extension\n  const type = detector_1.detector(buffer); // find an appropriate handler for this file type\n\n  if (type && type in types_1.typeHandlers) {\n    const size = types_1.typeHandlers[type].calculate(buffer, filepath);\n\n    if (size !== undefined) {\n      size.type = type;\n      return size;\n    }\n  } // throw up, if we don't understand the file\n\n\n  throw new TypeError('unsupported file type: ' + type + ' (file: ' + filepath + ')');\n}\n/**\n * Reads a file into a buffer.\n * @param {String} filepath\n * @returns {Promise<Buffer>}\n */\n\n\nfunction asyncFileToBuffer(filepath) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const handle = yield fs.promises.open(filepath, 'r');\n    const {\n      size\n    } = yield handle.stat();\n\n    if (size <= 0) {\n      yield handle.close();\n      throw new Error('Empty file');\n    }\n\n    const bufferSize = Math.min(size, MaxBufferSize);\n    const buffer = Buffer.alloc(bufferSize);\n    yield handle.read(buffer, 0, bufferSize, 0);\n    yield handle.close();\n    return buffer;\n  });\n}\n/**\n * Synchronously reads a file into a buffer, blocking the nodejs process.\n *\n * @param {String} filepath\n * @returns {Buffer}\n */\n\n\nfunction syncFileToBuffer(filepath) {\n  // read from the file, synchronously\n  const descriptor = fs.openSync(filepath, 'r');\n  const {\n    size\n  } = fs.fstatSync(descriptor);\n\n  if (size <= 0) {\n    fs.closeSync(descriptor);\n    throw new Error('Empty file');\n  }\n\n  const bufferSize = Math.min(size, MaxBufferSize);\n  const buffer = Buffer.alloc(bufferSize);\n  fs.readSync(descriptor, buffer, 0, bufferSize, 0);\n  fs.closeSync(descriptor);\n  return buffer;\n} // eslint-disable-next-line @typescript-eslint/no-use-before-define\n\n\nmodule.exports = exports = imageSize; // backwards compatibility\n\nexports.default = imageSize;\n/**\n * @param {Buffer|string} input - buffer or relative/absolute path of the image file\n * @param {Function=} [callback] - optional function for async detection\n */\n\nfunction imageSize(input, callback) {\n  // Handle buffer input\n  if (Buffer.isBuffer(input)) {\n    return lookup(input);\n  } // input should be a string at this point\n\n\n  if (typeof input !== 'string') {\n    throw new TypeError('invalid invocation');\n  } // resolve the file path\n\n\n  const filepath = path.resolve(input);\n\n  if (typeof callback === 'function') {\n    queue.push(() => asyncFileToBuffer(filepath).then(buffer => process.nextTick(callback, null, lookup(buffer, filepath))).catch(callback));\n  } else {\n    const buffer = syncFileToBuffer(filepath);\n    return lookup(buffer, filepath);\n  }\n}\n\nexports.imageSize = imageSize;\n\nexports.setConcurrency = c => {\n  queue.concurrency = c;\n};\n\nexports.types = Object.keys(types_1.typeHandlers);","map":{"version":3,"sources":["D:/Desktop/Em Yeu Website/node_modules/image-size/dist/index.js"],"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","Object","defineProperty","exports","types","setConcurrency","imageSize","fs","require","path","queue_1","types_1","detector_1","MaxBufferSize","queue","default","concurrency","autostart","lookup","buffer","filepath","type","detector","typeHandlers","size","calculate","undefined","TypeError","asyncFileToBuffer","handle","promises","open","stat","close","Error","bufferSize","Math","min","Buffer","alloc","read","syncFileToBuffer","descriptor","openSync","fstatSync","closeSync","readSync","module","input","callback","isBuffer","push","process","nextTick","catch","c","keys"],"mappings":"AAAA;;AACA,IAAIA,SAAS,GAAI,QAAQ,KAAKA,SAAd,IAA4B,UAAUC,OAAV,EAAmBC,UAAnB,EAA+BC,CAA/B,EAAkCC,SAAlC,EAA6C;AACrF,WAASC,KAAT,CAAeC,KAAf,EAAsB;AAAE,WAAOA,KAAK,YAAYH,CAAjB,GAAqBG,KAArB,GAA6B,IAAIH,CAAJ,CAAM,UAAUI,OAAV,EAAmB;AAAEA,MAAAA,OAAO,CAACD,KAAD,CAAP;AAAiB,KAA5C,CAApC;AAAoF;;AAC5G,SAAO,KAAKH,CAAC,KAAKA,CAAC,GAAGK,OAAT,CAAN,EAAyB,UAAUD,OAAV,EAAmBE,MAAnB,EAA2B;AACvD,aAASC,SAAT,CAAmBJ,KAAnB,EAA0B;AAAE,UAAI;AAAEK,QAAAA,IAAI,CAACP,SAAS,CAACQ,IAAV,CAAeN,KAAf,CAAD,CAAJ;AAA8B,OAApC,CAAqC,OAAOO,CAAP,EAAU;AAAEJ,QAAAA,MAAM,CAACI,CAAD,CAAN;AAAY;AAAE;;AAC3F,aAASC,QAAT,CAAkBR,KAAlB,EAAyB;AAAE,UAAI;AAAEK,QAAAA,IAAI,CAACP,SAAS,CAAC,OAAD,CAAT,CAAmBE,KAAnB,CAAD,CAAJ;AAAkC,OAAxC,CAAyC,OAAOO,CAAP,EAAU;AAAEJ,QAAAA,MAAM,CAACI,CAAD,CAAN;AAAY;AAAE;;AAC9F,aAASF,IAAT,CAAcI,MAAd,EAAsB;AAAEA,MAAAA,MAAM,CAACC,IAAP,GAAcT,OAAO,CAACQ,MAAM,CAACT,KAAR,CAArB,GAAsCD,KAAK,CAACU,MAAM,CAACT,KAAR,CAAL,CAAoBW,IAApB,CAAyBP,SAAzB,EAAoCI,QAApC,CAAtC;AAAsF;;AAC9GH,IAAAA,IAAI,CAAC,CAACP,SAAS,GAAGA,SAAS,CAACc,KAAV,CAAgBjB,OAAhB,EAAyBC,UAAU,IAAI,EAAvC,CAAb,EAAyDU,IAAzD,EAAD,CAAJ;AACH,GALM,CAAP;AAMH,CARD;;AASAO,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEf,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACAe,OAAO,CAACC,KAAR,GAAgBD,OAAO,CAACE,cAAR,GAAyBF,OAAO,CAACG,SAAR,GAAoB,KAAK,CAAlE;;AACA,MAAMC,EAAE,GAAGC,OAAO,CAAC,IAAD,CAAlB;;AACA,MAAMC,IAAI,GAAGD,OAAO,CAAC,MAAD,CAApB;;AACA,MAAME,OAAO,GAAGF,OAAO,CAAC,OAAD,CAAvB;;AACA,MAAMG,OAAO,GAAGH,OAAO,CAAC,SAAD,CAAvB;;AACA,MAAMI,UAAU,GAAGJ,OAAO,CAAC,YAAD,CAA1B,C,CACA;AACA;;;AACA,MAAMK,aAAa,GAAG,MAAM,IAA5B,C,CACA;;AACA,MAAMC,KAAK,GAAG,IAAIJ,OAAO,CAACK,OAAZ,CAAoB;AAAEC,EAAAA,WAAW,EAAE,GAAf;AAAoBC,EAAAA,SAAS,EAAE;AAA/B,CAApB,CAAd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASC,MAAT,CAAgBC,MAAhB,EAAwBC,QAAxB,EAAkC;AAC9B;AACA,QAAMC,IAAI,GAAGT,UAAU,CAACU,QAAX,CAAoBH,MAApB,CAAb,CAF8B,CAG9B;;AACA,MAAIE,IAAI,IAAIA,IAAI,IAAIV,OAAO,CAACY,YAA5B,EAA0C;AACtC,UAAMC,IAAI,GAAGb,OAAO,CAACY,YAAR,CAAqBF,IAArB,EAA2BI,SAA3B,CAAqCN,MAArC,EAA6CC,QAA7C,CAAb;;AACA,QAAII,IAAI,KAAKE,SAAb,EAAwB;AACpBF,MAAAA,IAAI,CAACH,IAAL,GAAYA,IAAZ;AACA,aAAOG,IAAP;AACH;AACJ,GAV6B,CAW9B;;;AACA,QAAM,IAAIG,SAAJ,CAAc,4BAA4BN,IAA5B,GAAmC,UAAnC,GAAgDD,QAAhD,GAA2D,GAAzE,CAAN;AACH;AACD;AACA;AACA;AACA;AACA;;;AACA,SAASQ,iBAAT,CAA2BR,QAA3B,EAAqC;AACjC,SAAOtC,SAAS,CAAC,IAAD,EAAO,KAAK,CAAZ,EAAe,KAAK,CAApB,EAAuB,aAAa;AAChD,UAAM+C,MAAM,GAAG,MAAMtB,EAAE,CAACuB,QAAH,CAAYC,IAAZ,CAAiBX,QAAjB,EAA2B,GAA3B,CAArB;AACA,UAAM;AAAEI,MAAAA;AAAF,QAAW,MAAMK,MAAM,CAACG,IAAP,EAAvB;;AACA,QAAIR,IAAI,IAAI,CAAZ,EAAe;AACX,YAAMK,MAAM,CAACI,KAAP,EAAN;AACA,YAAM,IAAIC,KAAJ,CAAU,YAAV,CAAN;AACH;;AACD,UAAMC,UAAU,GAAGC,IAAI,CAACC,GAAL,CAASb,IAAT,EAAeX,aAAf,CAAnB;AACA,UAAMM,MAAM,GAAGmB,MAAM,CAACC,KAAP,CAAaJ,UAAb,CAAf;AACA,UAAMN,MAAM,CAACW,IAAP,CAAYrB,MAAZ,EAAoB,CAApB,EAAuBgB,UAAvB,EAAmC,CAAnC,CAAN;AACA,UAAMN,MAAM,CAACI,KAAP,EAAN;AACA,WAAOd,MAAP;AACH,GAZe,CAAhB;AAaH;AACD;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASsB,gBAAT,CAA0BrB,QAA1B,EAAoC;AAChC;AACA,QAAMsB,UAAU,GAAGnC,EAAE,CAACoC,QAAH,CAAYvB,QAAZ,EAAsB,GAAtB,CAAnB;AACA,QAAM;AAAEI,IAAAA;AAAF,MAAWjB,EAAE,CAACqC,SAAH,CAAaF,UAAb,CAAjB;;AACA,MAAIlB,IAAI,IAAI,CAAZ,EAAe;AACXjB,IAAAA,EAAE,CAACsC,SAAH,CAAaH,UAAb;AACA,UAAM,IAAIR,KAAJ,CAAU,YAAV,CAAN;AACH;;AACD,QAAMC,UAAU,GAAGC,IAAI,CAACC,GAAL,CAASb,IAAT,EAAeX,aAAf,CAAnB;AACA,QAAMM,MAAM,GAAGmB,MAAM,CAACC,KAAP,CAAaJ,UAAb,CAAf;AACA5B,EAAAA,EAAE,CAACuC,QAAH,CAAYJ,UAAZ,EAAwBvB,MAAxB,EAAgC,CAAhC,EAAmCgB,UAAnC,EAA+C,CAA/C;AACA5B,EAAAA,EAAE,CAACsC,SAAH,CAAaH,UAAb;AACA,SAAOvB,MAAP;AACH,C,CACD;;;AACA4B,MAAM,CAAC5C,OAAP,GAAiBA,OAAO,GAAGG,SAA3B,C,CAAsC;;AACtCH,OAAO,CAACY,OAAR,GAAkBT,SAAlB;AACA;AACA;AACA;AACA;;AACA,SAASA,SAAT,CAAmB0C,KAAnB,EAA0BC,QAA1B,EAAoC;AAChC;AACA,MAAIX,MAAM,CAACY,QAAP,CAAgBF,KAAhB,CAAJ,EAA4B;AACxB,WAAO9B,MAAM,CAAC8B,KAAD,CAAb;AACH,GAJ+B,CAKhC;;;AACA,MAAI,OAAOA,KAAP,KAAiB,QAArB,EAA+B;AAC3B,UAAM,IAAIrB,SAAJ,CAAc,oBAAd,CAAN;AACH,GAR+B,CAShC;;;AACA,QAAMP,QAAQ,GAAGX,IAAI,CAACpB,OAAL,CAAa2D,KAAb,CAAjB;;AACA,MAAI,OAAOC,QAAP,KAAoB,UAAxB,EAAoC;AAChCnC,IAAAA,KAAK,CAACqC,IAAN,CAAW,MAAMvB,iBAAiB,CAACR,QAAD,CAAjB,CACZrB,IADY,CACNoB,MAAD,IAAYiC,OAAO,CAACC,QAAR,CAAiBJ,QAAjB,EAA2B,IAA3B,EAAiC/B,MAAM,CAACC,MAAD,EAASC,QAAT,CAAvC,CADL,EAEZkC,KAFY,CAENL,QAFM,CAAjB;AAGH,GAJD,MAKK;AACD,UAAM9B,MAAM,GAAGsB,gBAAgB,CAACrB,QAAD,CAA/B;AACA,WAAOF,MAAM,CAACC,MAAD,EAASC,QAAT,CAAb;AACH;AACJ;;AACDjB,OAAO,CAACG,SAAR,GAAoBA,SAApB;;AACAH,OAAO,CAACE,cAAR,GAA0BkD,CAAD,IAAO;AAAEzC,EAAAA,KAAK,CAACE,WAAN,GAAoBuC,CAApB;AAAwB,CAA1D;;AACApD,OAAO,CAACC,KAAR,GAAgBH,MAAM,CAACuD,IAAP,CAAY7C,OAAO,CAACY,YAApB,CAAhB","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.types = exports.setConcurrency = exports.imageSize = void 0;\nconst fs = require(\"fs\");\nconst path = require(\"path\");\nconst queue_1 = require(\"queue\");\nconst types_1 = require(\"./types\");\nconst detector_1 = require(\"./detector\");\n// Maximum buffer size, with a default of 512 kilobytes.\n// TO-DO: make this adaptive based on the initial signature of the image\nconst MaxBufferSize = 512 * 1024;\n// This queue is for async `fs` operations, to avoid reaching file-descriptor limits\nconst queue = new queue_1.default({ concurrency: 100, autostart: true });\n/**\n * Return size information based on a buffer\n *\n * @param {Buffer} buffer\n * @param {String} filepath\n * @returns {Object}\n */\nfunction lookup(buffer, filepath) {\n    // detect the file type.. don't rely on the extension\n    const type = detector_1.detector(buffer);\n    // find an appropriate handler for this file type\n    if (type && type in types_1.typeHandlers) {\n        const size = types_1.typeHandlers[type].calculate(buffer, filepath);\n        if (size !== undefined) {\n            size.type = type;\n            return size;\n        }\n    }\n    // throw up, if we don't understand the file\n    throw new TypeError('unsupported file type: ' + type + ' (file: ' + filepath + ')');\n}\n/**\n * Reads a file into a buffer.\n * @param {String} filepath\n * @returns {Promise<Buffer>}\n */\nfunction asyncFileToBuffer(filepath) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const handle = yield fs.promises.open(filepath, 'r');\n        const { size } = yield handle.stat();\n        if (size <= 0) {\n            yield handle.close();\n            throw new Error('Empty file');\n        }\n        const bufferSize = Math.min(size, MaxBufferSize);\n        const buffer = Buffer.alloc(bufferSize);\n        yield handle.read(buffer, 0, bufferSize, 0);\n        yield handle.close();\n        return buffer;\n    });\n}\n/**\n * Synchronously reads a file into a buffer, blocking the nodejs process.\n *\n * @param {String} filepath\n * @returns {Buffer}\n */\nfunction syncFileToBuffer(filepath) {\n    // read from the file, synchronously\n    const descriptor = fs.openSync(filepath, 'r');\n    const { size } = fs.fstatSync(descriptor);\n    if (size <= 0) {\n        fs.closeSync(descriptor);\n        throw new Error('Empty file');\n    }\n    const bufferSize = Math.min(size, MaxBufferSize);\n    const buffer = Buffer.alloc(bufferSize);\n    fs.readSync(descriptor, buffer, 0, bufferSize, 0);\n    fs.closeSync(descriptor);\n    return buffer;\n}\n// eslint-disable-next-line @typescript-eslint/no-use-before-define\nmodule.exports = exports = imageSize; // backwards compatibility\nexports.default = imageSize;\n/**\n * @param {Buffer|string} input - buffer or relative/absolute path of the image file\n * @param {Function=} [callback] - optional function for async detection\n */\nfunction imageSize(input, callback) {\n    // Handle buffer input\n    if (Buffer.isBuffer(input)) {\n        return lookup(input);\n    }\n    // input should be a string at this point\n    if (typeof input !== 'string') {\n        throw new TypeError('invalid invocation');\n    }\n    // resolve the file path\n    const filepath = path.resolve(input);\n    if (typeof callback === 'function') {\n        queue.push(() => asyncFileToBuffer(filepath)\n            .then((buffer) => process.nextTick(callback, null, lookup(buffer, filepath)))\n            .catch(callback));\n    }\n    else {\n        const buffer = syncFileToBuffer(filepath);\n        return lookup(buffer, filepath);\n    }\n}\nexports.imageSize = imageSize;\nexports.setConcurrency = (c) => { queue.concurrency = c; };\nexports.types = Object.keys(types_1.typeHandlers);\n"]},"metadata":{},"sourceType":"script"}