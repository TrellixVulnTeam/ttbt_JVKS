{"ast":null,"code":"\"use strict\"; // NOTE: we only support baseline and progressive JPGs here\n// due to the structure of the loader class, we only get a buffer\n// with a maximum size of 4096 bytes. so if the SOF marker is outside\n// if this range we can't detect the file size correctly.\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.JPG = void 0;\n\nconst readUInt_1 = require(\"../readUInt\");\n\nconst EXIF_MARKER = '45786966';\nconst APP1_DATA_SIZE_BYTES = 2;\nconst EXIF_HEADER_BYTES = 6;\nconst TIFF_BYTE_ALIGN_BYTES = 2;\nconst BIG_ENDIAN_BYTE_ALIGN = '4d4d';\nconst LITTLE_ENDIAN_BYTE_ALIGN = '4949'; // Each entry is exactly 12 bytes\n\nconst IDF_ENTRY_BYTES = 12;\nconst NUM_DIRECTORY_ENTRIES_BYTES = 2;\n\nfunction isEXIF(buffer) {\n  return buffer.toString('hex', 2, 6) === EXIF_MARKER;\n}\n\nfunction extractSize(buffer, index) {\n  return {\n    height: buffer.readUInt16BE(index),\n    width: buffer.readUInt16BE(index + 2)\n  };\n}\n\nfunction extractOrientation(exifBlock, isBigEndian) {\n  // TODO: assert that this contains 0x002A\n  // let STATIC_MOTOROLA_TIFF_HEADER_BYTES = 2\n  // let TIFF_IMAGE_FILE_DIRECTORY_BYTES = 4\n  // TODO: derive from TIFF_IMAGE_FILE_DIRECTORY_BYTES\n  const idfOffset = 8; // IDF osset works from right after the header bytes\n  // (so the offset includes the tiff byte align)\n\n  const offset = EXIF_HEADER_BYTES + idfOffset;\n  const idfDirectoryEntries = readUInt_1.readUInt(exifBlock, 16, offset, isBigEndian);\n\n  for (let directoryEntryNumber = 0; directoryEntryNumber < idfDirectoryEntries; directoryEntryNumber++) {\n    const start = offset + NUM_DIRECTORY_ENTRIES_BYTES + directoryEntryNumber * IDF_ENTRY_BYTES;\n    const end = start + IDF_ENTRY_BYTES; // Skip on corrupt EXIF blocks\n\n    if (start > exifBlock.length) {\n      return;\n    }\n\n    const block = exifBlock.slice(start, end);\n    const tagNumber = readUInt_1.readUInt(block, 16, 0, isBigEndian); // 0x0112 (decimal: 274) is the `orientation` tag ID\n\n    if (tagNumber === 274) {\n      const dataFormat = readUInt_1.readUInt(block, 16, 2, isBigEndian);\n\n      if (dataFormat !== 3) {\n        return;\n      } // unsinged int has 2 bytes per component\n      // if there would more than 4 bytes in total it's a pointer\n\n\n      const numberOfComponents = readUInt_1.readUInt(block, 32, 4, isBigEndian);\n\n      if (numberOfComponents !== 1) {\n        return;\n      }\n\n      return readUInt_1.readUInt(block, 16, 8, isBigEndian);\n    }\n  }\n}\n\nfunction validateExifBlock(buffer, index) {\n  // Skip APP1 Data Size\n  const exifBlock = buffer.slice(APP1_DATA_SIZE_BYTES, index); // Consider byte alignment\n\n  const byteAlign = exifBlock.toString('hex', EXIF_HEADER_BYTES, EXIF_HEADER_BYTES + TIFF_BYTE_ALIGN_BYTES); // Ignore Empty EXIF. Validate byte alignment\n\n  const isBigEndian = byteAlign === BIG_ENDIAN_BYTE_ALIGN;\n  const isLittleEndian = byteAlign === LITTLE_ENDIAN_BYTE_ALIGN;\n\n  if (isBigEndian || isLittleEndian) {\n    return extractOrientation(exifBlock, isBigEndian);\n  }\n}\n\nfunction validateBuffer(buffer, index) {\n  // index should be within buffer limits\n  if (index > buffer.length) {\n    throw new TypeError('Corrupt JPG, exceeded buffer limits');\n  } // Every JPEG block must begin with a 0xFF\n\n\n  if (buffer[index] !== 0xFF) {\n    throw new TypeError('Invalid JPG, marker table corrupted');\n  }\n}\n\nexports.JPG = {\n  validate(buffer) {\n    const SOIMarker = buffer.toString('hex', 0, 2);\n    return 'ffd8' === SOIMarker;\n  },\n\n  calculate(buffer) {\n    // Skip 4 chars, they are for signature\n    buffer = buffer.slice(4);\n    let orientation;\n    let next;\n\n    while (buffer.length) {\n      // read length of the next block\n      const i = buffer.readUInt16BE(0);\n\n      if (isEXIF(buffer)) {\n        orientation = validateExifBlock(buffer, i);\n      } // ensure correct format\n\n\n      validateBuffer(buffer, i); // 0xFFC0 is baseline standard(SOF)\n      // 0xFFC1 is baseline optimized(SOF)\n      // 0xFFC2 is progressive(SOF2)\n\n      next = buffer[i + 1];\n\n      if (next === 0xC0 || next === 0xC1 || next === 0xC2) {\n        const size = extractSize(buffer, i + 5); // TODO: is orientation=0 a valid answer here?\n\n        if (!orientation) {\n          return size;\n        }\n\n        return {\n          height: size.height,\n          orientation,\n          width: size.width\n        };\n      } // move to the next block\n\n\n      buffer = buffer.slice(i + 2);\n    }\n\n    throw new TypeError('Invalid JPG, no size found');\n  }\n\n};","map":{"version":3,"sources":["D:/Desktop/Em Yeu Website/node_modules/image-size/dist/types/jpg.js"],"names":["Object","defineProperty","exports","value","JPG","readUInt_1","require","EXIF_MARKER","APP1_DATA_SIZE_BYTES","EXIF_HEADER_BYTES","TIFF_BYTE_ALIGN_BYTES","BIG_ENDIAN_BYTE_ALIGN","LITTLE_ENDIAN_BYTE_ALIGN","IDF_ENTRY_BYTES","NUM_DIRECTORY_ENTRIES_BYTES","isEXIF","buffer","toString","extractSize","index","height","readUInt16BE","width","extractOrientation","exifBlock","isBigEndian","idfOffset","offset","idfDirectoryEntries","readUInt","directoryEntryNumber","start","end","length","block","slice","tagNumber","dataFormat","numberOfComponents","validateExifBlock","byteAlign","isLittleEndian","validateBuffer","TypeError","validate","SOIMarker","calculate","orientation","next","i","size"],"mappings":"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","sourcesContent":["\"use strict\";\n// NOTE: we only support baseline and progressive JPGs here\n// due to the structure of the loader class, we only get a buffer\n// with a maximum size of 4096 bytes. so if the SOF marker is outside\n// if this range we can't detect the file size correctly.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.JPG = void 0;\nconst readUInt_1 = require(\"../readUInt\");\nconst EXIF_MARKER = '45786966';\nconst APP1_DATA_SIZE_BYTES = 2;\nconst EXIF_HEADER_BYTES = 6;\nconst TIFF_BYTE_ALIGN_BYTES = 2;\nconst BIG_ENDIAN_BYTE_ALIGN = '4d4d';\nconst LITTLE_ENDIAN_BYTE_ALIGN = '4949';\n// Each entry is exactly 12 bytes\nconst IDF_ENTRY_BYTES = 12;\nconst NUM_DIRECTORY_ENTRIES_BYTES = 2;\nfunction isEXIF(buffer) {\n    return (buffer.toString('hex', 2, 6) === EXIF_MARKER);\n}\nfunction extractSize(buffer, index) {\n    return {\n        height: buffer.readUInt16BE(index),\n        width: buffer.readUInt16BE(index + 2)\n    };\n}\nfunction extractOrientation(exifBlock, isBigEndian) {\n    // TODO: assert that this contains 0x002A\n    // let STATIC_MOTOROLA_TIFF_HEADER_BYTES = 2\n    // let TIFF_IMAGE_FILE_DIRECTORY_BYTES = 4\n    // TODO: derive from TIFF_IMAGE_FILE_DIRECTORY_BYTES\n    const idfOffset = 8;\n    // IDF osset works from right after the header bytes\n    // (so the offset includes the tiff byte align)\n    const offset = EXIF_HEADER_BYTES + idfOffset;\n    const idfDirectoryEntries = readUInt_1.readUInt(exifBlock, 16, offset, isBigEndian);\n    for (let directoryEntryNumber = 0; directoryEntryNumber < idfDirectoryEntries; directoryEntryNumber++) {\n        const start = offset + NUM_DIRECTORY_ENTRIES_BYTES + (directoryEntryNumber * IDF_ENTRY_BYTES);\n        const end = start + IDF_ENTRY_BYTES;\n        // Skip on corrupt EXIF blocks\n        if (start > exifBlock.length) {\n            return;\n        }\n        const block = exifBlock.slice(start, end);\n        const tagNumber = readUInt_1.readUInt(block, 16, 0, isBigEndian);\n        // 0x0112 (decimal: 274) is the `orientation` tag ID\n        if (tagNumber === 274) {\n            const dataFormat = readUInt_1.readUInt(block, 16, 2, isBigEndian);\n            if (dataFormat !== 3) {\n                return;\n            }\n            // unsinged int has 2 bytes per component\n            // if there would more than 4 bytes in total it's a pointer\n            const numberOfComponents = readUInt_1.readUInt(block, 32, 4, isBigEndian);\n            if (numberOfComponents !== 1) {\n                return;\n            }\n            return readUInt_1.readUInt(block, 16, 8, isBigEndian);\n        }\n    }\n}\nfunction validateExifBlock(buffer, index) {\n    // Skip APP1 Data Size\n    const exifBlock = buffer.slice(APP1_DATA_SIZE_BYTES, index);\n    // Consider byte alignment\n    const byteAlign = exifBlock.toString('hex', EXIF_HEADER_BYTES, EXIF_HEADER_BYTES + TIFF_BYTE_ALIGN_BYTES);\n    // Ignore Empty EXIF. Validate byte alignment\n    const isBigEndian = byteAlign === BIG_ENDIAN_BYTE_ALIGN;\n    const isLittleEndian = byteAlign === LITTLE_ENDIAN_BYTE_ALIGN;\n    if (isBigEndian || isLittleEndian) {\n        return extractOrientation(exifBlock, isBigEndian);\n    }\n}\nfunction validateBuffer(buffer, index) {\n    // index should be within buffer limits\n    if (index > buffer.length) {\n        throw new TypeError('Corrupt JPG, exceeded buffer limits');\n    }\n    // Every JPEG block must begin with a 0xFF\n    if (buffer[index] !== 0xFF) {\n        throw new TypeError('Invalid JPG, marker table corrupted');\n    }\n}\nexports.JPG = {\n    validate(buffer) {\n        const SOIMarker = buffer.toString('hex', 0, 2);\n        return ('ffd8' === SOIMarker);\n    },\n    calculate(buffer) {\n        // Skip 4 chars, they are for signature\n        buffer = buffer.slice(4);\n        let orientation;\n        let next;\n        while (buffer.length) {\n            // read length of the next block\n            const i = buffer.readUInt16BE(0);\n            if (isEXIF(buffer)) {\n                orientation = validateExifBlock(buffer, i);\n            }\n            // ensure correct format\n            validateBuffer(buffer, i);\n            // 0xFFC0 is baseline standard(SOF)\n            // 0xFFC1 is baseline optimized(SOF)\n            // 0xFFC2 is progressive(SOF2)\n            next = buffer[i + 1];\n            if (next === 0xC0 || next === 0xC1 || next === 0xC2) {\n                const size = extractSize(buffer, i + 5);\n                // TODO: is orientation=0 a valid answer here?\n                if (!orientation) {\n                    return size;\n                }\n                return {\n                    height: size.height,\n                    orientation,\n                    width: size.width\n                };\n            }\n            // move to the next block\n            buffer = buffer.slice(i + 2);\n        }\n        throw new TypeError('Invalid JPG, no size found');\n    }\n};\n"]},"metadata":{},"sourceType":"script"}