{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.JP2 = void 0;\nconst BoxTypes = {\n  ftyp: '66747970',\n  ihdr: '69686472',\n  jp2h: '6a703268',\n  jp__: '6a502020',\n  rreq: '72726571',\n  xml_: '786d6c20'\n};\n\nconst calculateRREQLength = box => {\n  const unit = box.readUInt8(0);\n  let offset = 1 + 2 * unit;\n  const numStdFlags = box.readUInt16BE(offset);\n  const flagsLength = numStdFlags * (2 + unit);\n  offset = offset + 2 + flagsLength;\n  const numVendorFeatures = box.readUInt16BE(offset);\n  const featuresLength = numVendorFeatures * (16 + unit);\n  return offset + 2 + featuresLength;\n};\n\nconst parseIHDR = box => {\n  return {\n    height: box.readUInt32BE(4),\n    width: box.readUInt32BE(8)\n  };\n};\n\nexports.JP2 = {\n  validate(buffer) {\n    const signature = buffer.toString('hex', 4, 8);\n    const signatureLength = buffer.readUInt32BE(0);\n\n    if (signature !== BoxTypes.jp__ || signatureLength < 1) {\n      return false;\n    }\n\n    const ftypeBoxStart = signatureLength + 4;\n    const ftypBoxLength = buffer.readUInt32BE(signatureLength);\n    const ftypBox = buffer.slice(ftypeBoxStart, ftypeBoxStart + ftypBoxLength);\n    return ftypBox.toString('hex', 0, 4) === BoxTypes.ftyp;\n  },\n\n  calculate(buffer) {\n    const signatureLength = buffer.readUInt32BE(0);\n    const ftypBoxLength = buffer.readUInt16BE(signatureLength + 2);\n    let offset = signatureLength + 4 + ftypBoxLength;\n    const nextBoxType = buffer.toString('hex', offset, offset + 4);\n\n    switch (nextBoxType) {\n      case BoxTypes.rreq:\n        // WHAT ARE THESE 4 BYTES?????\n        // eslint-disable-next-line no-case-declarations\n        const MAGIC = 4;\n        offset = offset + 4 + MAGIC + calculateRREQLength(buffer.slice(offset + 4));\n        return parseIHDR(buffer.slice(offset + 8, offset + 24));\n\n      case BoxTypes.jp2h:\n        return parseIHDR(buffer.slice(offset + 8, offset + 24));\n\n      default:\n        throw new TypeError('Unsupported header found: ' + buffer.toString('ascii', offset, offset + 4));\n    }\n  }\n\n};","map":{"version":3,"sources":["D:/Desktop/Em Yeu Website/node_modules/image-size/dist/types/jp2.js"],"names":["Object","defineProperty","exports","value","JP2","BoxTypes","ftyp","ihdr","jp2h","jp__","rreq","xml_","calculateRREQLength","box","unit","readUInt8","offset","numStdFlags","readUInt16BE","flagsLength","numVendorFeatures","featuresLength","parseIHDR","height","readUInt32BE","width","validate","buffer","signature","toString","signatureLength","ftypeBoxStart","ftypBoxLength","ftypBox","slice","calculate","nextBoxType","MAGIC","TypeError"],"mappings":"AAAA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,GAAR,GAAc,KAAK,CAAnB;AACA,MAAMC,QAAQ,GAAG;AACbC,EAAAA,IAAI,EAAE,UADO;AAEbC,EAAAA,IAAI,EAAE,UAFO;AAGbC,EAAAA,IAAI,EAAE,UAHO;AAIbC,EAAAA,IAAI,EAAE,UAJO;AAKbC,EAAAA,IAAI,EAAE,UALO;AAMbC,EAAAA,IAAI,EAAE;AANO,CAAjB;;AAQA,MAAMC,mBAAmB,GAAIC,GAAD,IAAS;AACjC,QAAMC,IAAI,GAAGD,GAAG,CAACE,SAAJ,CAAc,CAAd,CAAb;AACA,MAAIC,MAAM,GAAG,IAAK,IAAIF,IAAtB;AACA,QAAMG,WAAW,GAAGJ,GAAG,CAACK,YAAJ,CAAiBF,MAAjB,CAApB;AACA,QAAMG,WAAW,GAAGF,WAAW,IAAI,IAAIH,IAAR,CAA/B;AACAE,EAAAA,MAAM,GAAGA,MAAM,GAAG,CAAT,GAAaG,WAAtB;AACA,QAAMC,iBAAiB,GAAGP,GAAG,CAACK,YAAJ,CAAiBF,MAAjB,CAA1B;AACA,QAAMK,cAAc,GAAGD,iBAAiB,IAAI,KAAKN,IAAT,CAAxC;AACA,SAAOE,MAAM,GAAG,CAAT,GAAaK,cAApB;AACH,CATD;;AAUA,MAAMC,SAAS,GAAIT,GAAD,IAAS;AACvB,SAAO;AACHU,IAAAA,MAAM,EAAEV,GAAG,CAACW,YAAJ,CAAiB,CAAjB,CADL;AAEHC,IAAAA,KAAK,EAAEZ,GAAG,CAACW,YAAJ,CAAiB,CAAjB;AAFJ,GAAP;AAIH,CALD;;AAMAtB,OAAO,CAACE,GAAR,GAAc;AACVsB,EAAAA,QAAQ,CAACC,MAAD,EAAS;AACb,UAAMC,SAAS,GAAGD,MAAM,CAACE,QAAP,CAAgB,KAAhB,EAAuB,CAAvB,EAA0B,CAA1B,CAAlB;AACA,UAAMC,eAAe,GAAGH,MAAM,CAACH,YAAP,CAAoB,CAApB,CAAxB;;AACA,QAAII,SAAS,KAAKvB,QAAQ,CAACI,IAAvB,IAA+BqB,eAAe,GAAG,CAArD,EAAwD;AACpD,aAAO,KAAP;AACH;;AACD,UAAMC,aAAa,GAAGD,eAAe,GAAG,CAAxC;AACA,UAAME,aAAa,GAAGL,MAAM,CAACH,YAAP,CAAoBM,eAApB,CAAtB;AACA,UAAMG,OAAO,GAAGN,MAAM,CAACO,KAAP,CAAaH,aAAb,EAA4BA,aAAa,GAAGC,aAA5C,CAAhB;AACA,WAAOC,OAAO,CAACJ,QAAR,CAAiB,KAAjB,EAAwB,CAAxB,EAA2B,CAA3B,MAAkCxB,QAAQ,CAACC,IAAlD;AACH,GAXS;;AAYV6B,EAAAA,SAAS,CAACR,MAAD,EAAS;AACd,UAAMG,eAAe,GAAGH,MAAM,CAACH,YAAP,CAAoB,CAApB,CAAxB;AACA,UAAMQ,aAAa,GAAGL,MAAM,CAACT,YAAP,CAAoBY,eAAe,GAAG,CAAtC,CAAtB;AACA,QAAId,MAAM,GAAGc,eAAe,GAAG,CAAlB,GAAsBE,aAAnC;AACA,UAAMI,WAAW,GAAGT,MAAM,CAACE,QAAP,CAAgB,KAAhB,EAAuBb,MAAvB,EAA+BA,MAAM,GAAG,CAAxC,CAApB;;AACA,YAAQoB,WAAR;AACI,WAAK/B,QAAQ,CAACK,IAAd;AACI;AACA;AACA,cAAM2B,KAAK,GAAG,CAAd;AACArB,QAAAA,MAAM,GAAGA,MAAM,GAAG,CAAT,GAAaqB,KAAb,GAAqBzB,mBAAmB,CAACe,MAAM,CAACO,KAAP,CAAalB,MAAM,GAAG,CAAtB,CAAD,CAAjD;AACA,eAAOM,SAAS,CAACK,MAAM,CAACO,KAAP,CAAalB,MAAM,GAAG,CAAtB,EAAyBA,MAAM,GAAG,EAAlC,CAAD,CAAhB;;AACJ,WAAKX,QAAQ,CAACG,IAAd;AACI,eAAOc,SAAS,CAACK,MAAM,CAACO,KAAP,CAAalB,MAAM,GAAG,CAAtB,EAAyBA,MAAM,GAAG,EAAlC,CAAD,CAAhB;;AACJ;AACI,cAAM,IAAIsB,SAAJ,CAAc,+BAA+BX,MAAM,CAACE,QAAP,CAAgB,OAAhB,EAAyBb,MAAzB,EAAiCA,MAAM,GAAG,CAA1C,CAA7C,CAAN;AAVR;AAYH;;AA7BS,CAAd","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.JP2 = void 0;\nconst BoxTypes = {\n    ftyp: '66747970',\n    ihdr: '69686472',\n    jp2h: '6a703268',\n    jp__: '6a502020',\n    rreq: '72726571',\n    xml_: '786d6c20'\n};\nconst calculateRREQLength = (box) => {\n    const unit = box.readUInt8(0);\n    let offset = 1 + (2 * unit);\n    const numStdFlags = box.readUInt16BE(offset);\n    const flagsLength = numStdFlags * (2 + unit);\n    offset = offset + 2 + flagsLength;\n    const numVendorFeatures = box.readUInt16BE(offset);\n    const featuresLength = numVendorFeatures * (16 + unit);\n    return offset + 2 + featuresLength;\n};\nconst parseIHDR = (box) => {\n    return {\n        height: box.readUInt32BE(4),\n        width: box.readUInt32BE(8),\n    };\n};\nexports.JP2 = {\n    validate(buffer) {\n        const signature = buffer.toString('hex', 4, 8);\n        const signatureLength = buffer.readUInt32BE(0);\n        if (signature !== BoxTypes.jp__ || signatureLength < 1) {\n            return false;\n        }\n        const ftypeBoxStart = signatureLength + 4;\n        const ftypBoxLength = buffer.readUInt32BE(signatureLength);\n        const ftypBox = buffer.slice(ftypeBoxStart, ftypeBoxStart + ftypBoxLength);\n        return ftypBox.toString('hex', 0, 4) === BoxTypes.ftyp;\n    },\n    calculate(buffer) {\n        const signatureLength = buffer.readUInt32BE(0);\n        const ftypBoxLength = buffer.readUInt16BE(signatureLength + 2);\n        let offset = signatureLength + 4 + ftypBoxLength;\n        const nextBoxType = buffer.toString('hex', offset, offset + 4);\n        switch (nextBoxType) {\n            case BoxTypes.rreq:\n                // WHAT ARE THESE 4 BYTES?????\n                // eslint-disable-next-line no-case-declarations\n                const MAGIC = 4;\n                offset = offset + 4 + MAGIC + calculateRREQLength(buffer.slice(offset + 4));\n                return parseIHDR(buffer.slice(offset + 8, offset + 24));\n            case BoxTypes.jp2h:\n                return parseIHDR(buffer.slice(offset + 8, offset + 24));\n            default:\n                throw new TypeError('Unsupported header found: ' + buffer.toString('ascii', offset, offset + 4));\n        }\n    }\n};\n"]},"metadata":{},"sourceType":"script"}